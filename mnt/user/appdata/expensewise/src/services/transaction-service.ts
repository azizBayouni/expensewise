
import { firestore, storage } from '@/lib/firebase';
import {
  collection,
  addDoc,
  getDocs,
  updateDoc,
  deleteDoc,
  doc,
  query,
  where,
  writeBatch,
} from 'firebase/firestore';
import { ref, uploadBytes, getDownloadURL, deleteObject } from 'firebase/storage';
import { getExchangeRateApiKey } from './api-key-service';
import type { Transaction as AppTransaction } from '@/lib/data';

// We omit the id because it's generated by Firestore
export type Transaction = Omit<AppTransaction, 'id'>;

const transactionsCollection = (userId: string) => collection(firestore, 'users', userId, 'transactions');

async function uploadAttachment(userId: string, transactionId: string, file: File): Promise<{name: string, url: string}> {
    const storageRef = ref(storage, `users/${userId}/transactions/${transactionId}/${file.name}`);
    await uploadBytes(storageRef, file);
    const url = await getDownloadURL(storageRef);
    return { name: file.name, url };
}

export async function addTransaction(userId: string, newTransaction: Transaction, newAttachments: File[]): Promise<void> {
    const { attachments, ...transactionData } = newTransaction;
    const docRef = await addDoc(transactionsCollection(userId), transactionData);
    
    if (newAttachments && newAttachments.length > 0) {
        const attachmentUrls = await Promise.all(
            newAttachments.map(file => uploadAttachment(userId, docRef.id, file))
        );
        await updateDoc(docRef, { attachments: attachmentUrls });
    }

    window.dispatchEvent(new Event('transactionsUpdated'));
}

export async function addTransactions(userId: string, newTransactions: Omit<AppTransaction, 'id' | 'userId' | 'attachments'>[]): Promise<void> {
    const batch = writeBatch(firestore);
    newTransactions.forEach((t) => {
        const docRef = doc(transactionsCollection(userId));
        batch.set(docRef, {...t, userId});
    });
    await batch.commit();
    window.dispatchEvent(new Event('transactionsUpdated'));
}

export async function getAllTransactions(userId: string): Promise<AppTransaction[]> {
    const q = query(transactionsCollection(userId));
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as AppTransaction));
}

export async function getTransactionsForWallet(userId: string, walletName: string): Promise<AppTransaction[]> {
    const q = query(transactionsCollection(userId), where("wallet", "==", walletName));
    const querySnapshot = await getDocs(q);
    return querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as AppTransaction));
}

export async function updateTransaction(userId: string, updatedTransaction: AppTransaction, newAttachments: File[]): Promise<void> {
    const { id, attachments, ...transactionData } = updatedTransaction;
    const docRef = doc(firestore, 'users', userId, 'transactions', id);
    
    let finalAttachments = attachments || [];

    if (newAttachments && newAttachments.length > 0) {
        const newAttachmentUrls = await Promise.all(
            newAttachments.map(file => uploadAttachment(userId, id, file))
        );
        finalAttachments = [...finalAttachments, ...newAttachmentUrls];
    }
    
    await updateDoc(docRef, {...transactionData, attachments: finalAttachments });
    
    window.dispatchEvent(new Event('transactionsUpdated'));
}

export async function deleteTransaction(userId: string, transactionId: string): Promise<void> {
    const docRef = doc(firestore, 'users', userId, 'transactions', transactionId);
    await deleteDoc(docRef);
    
    // Optionally, delete attachments from storage
    // const storageFolderRef = ref(storage, `users/${userId}/transactions/${transactionId}`);
    // You would list and delete files here. For simplicity, we're skipping this.

    window.dispatchEvent(new Event('transactionsUpdated'));
}

export async function deleteAllTransactions(userId: string): Promise<void> {
    const q = query(transactionsCollection(userId));
    const querySnapshot = await getDocs(q);
    const batch = writeBatch(firestore);
    querySnapshot.docs.forEach(d => {
        batch.delete(d.ref);
    });
    await batch.commit();
    window.dispatchEvent(new Event('transactionsUpdated'));
}

async function getExchangeRate(userId: string, fromCurrency: string, toCurrency: string): Promise<number> {
    const apiKey = await getExchangeRateApiKey(userId);
    if (!apiKey) {
      throw new Error("ExchangeRate API Key not found. Please set it in the settings.");
    }
    if (fromCurrency === toCurrency) {
      return 1;
    }

    const url = `https://v6.exchangerate-api.com/v6/${apiKey}/latest/${fromCurrency}`;
    try {
        const response = await fetch(url);
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            const errorType = errorData['error-type'] || `HTTP status ${response.status}`;
            console.error(`API request failed with status: ${response.status}`, errorData);
            throw new Error(`API request failed: ${errorType}`);
        }
        const data = await response.json();
        if (data.result === 'error') {
            console.error(`ExchangeRate API error: ${data['error-type']}`);
            throw new Error(`ExchangeRate API error: ${data['error-type']}`);
        }
        const rate = data.conversion_rates?.[toCurrency];
        if (!rate) {
            throw new Error(`Could not find rate for ${toCurrency}`);
        }
        return rate;
    } catch(error) {
        console.error("Failed to fetch exchange rate. Full error:", error);
        throw error;
    }
}

export async function convertAmount(userId: string, amount: number, fromCurrency: string, toCurrency: string): Promise<number> {
    if (fromCurrency === toCurrency) {
        return amount;
    }
    const exchangeRate = await getExchangeRate(userId, fromCurrency, toCurrency);
    return amount * exchangeRate;
}


export async function convertAllTransactions(userId: string, fromCurrency: string, toCurrency: string): Promise<void> {
    const allTransactions = await getAllTransactions(userId);
    const batch = writeBatch(firestore);

    for (const transaction of allTransactions) {
        if (transaction.currency === fromCurrency) {
            const docRef = doc(firestore, 'users', userId, 'transactions', transaction.id);
            const convertedAmount = await convertAmount(userId, transaction.amount, fromCurrency, toCurrency);
            batch.update(docRef, {
                amount: convertedAmount,
                currency: toCurrency,
            });
        }
    }
    await batch.commit();
}

    